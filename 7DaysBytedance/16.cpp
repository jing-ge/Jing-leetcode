// 最短移动距离
// 给定一棵 n 个节点树。节点 1 为树的根节点，对于所有其他节点 i，它们的父节点编号为 floor(i/2) (i 除以 2 的整数部分)。在每个节点 i 上有 a[i] 个房间。此外树上所有边均是边长为 1 的无向边。
// 树上一共有 m 只松鼠，第 j 只松鼠的初始位置为 b[j]，它们需要通过树边各自找到一个独立的房间。请为所有松鼠规划一个移动方案，使得所有松鼠的总移动距离最短。

// 输入描述:
// 输入共有三行。

// 第一行包含两个正整数 n 和 m，表示树的节点数和松鼠的个数。

// 第二行包含 n 个自然数，其中第 i 个数表示节点 i 的房间数 a[i]。

// 第三行包含 m 个正整数，其中第 j 个数表示松鼠 j 的初始位置 b[j]。

// 输出描述:
// 输出一个数，表示 m 只松鼠各自找到独立房间的最短总移动距离。

// 测试用例
// 输入
// 5 4
// 0 0 4 1 1
// 5 4 2 2
// 输出
// 4
// 说明
// 前两只松鼠不需要移动，后两只松鼠需要经节点 1 移动到节点 3

// 备注
// 对于 30% 的数据，满足 n,m <=100。
// 对于 50% 的数据，满足 n,m <=1000。
// 对于所有数据，满足 n,m<=100000，0<=a[i]<=m, 1<=b[j]<=n。

// 作者：字节校园
// 链接：https://leetcode-cn.com/leetbook/read/bytedance-c01/eu4vir/
// 来源：力扣（LeetCode）
// 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

#include <algorithm>
#include <cstdio>

using namespace std;

typedef pair<int, int> pii;
#define F first
#define S second

const int MAXN = 100005;
pii now, f[MAXN];
int c[MAXN], dir[MAXN];
int n, m, lca, ans;

inline int calc(int a, int b) {
    return a * b < 0 ? -1 : 1;
}

//
inline void update(int x) {
	//当前是否有房间 
    f[x] = c[x] ? pii(0, x) : pii(MAXN, MAXN);
	//左子结点
    int y = x * 2;
	//左边最近的房间，且目的地为f[y].S   路径长度为f[x].F（不一定真实存在，看f[y].F和S的取值）
    if (y <= n && f[y].F + calc(dir[y], 1) < f[x].F)
        f[x] = pii(f[y].F + calc(dir[y], 1), f[y].S);
	//右边最近的房间，且目的地为f[y].S   路径长度为f[x].F
    if (++y <= n && f[y].F + calc(dir[y], 1) < f[x].F)
        f[x] = pii(f[y].F + calc(dir[y], 1), f[y].S);
}

void query(int x, int ret) {
	//当前子树下面是否有房间,是否比当前最近的距离还小
    if (f[x].F + ret < now.F)
		//更新目标位置，lca记录最近公共祖先的位置
        lca = x, now = pii(f[x].F + ret, f[x].S);
	//判断是否往父节点方向是否更优
    if (x != 1)
        query(x / 2, ret + calc(dir[x], -1));
}

/*当x!=lca时 
修正1：当沿着某结点往上走时，需要修正后续沿着该点往下走的代价

修正lca到x之间的路径方向，即：如果前一个松鼠选择的路径是沿着x-->lca方向，即x到lca的中间的结点(含x,不含lca)都走父节点方向，当后一个松鼠的路径存在lca-->x方向中的某些连续边,即x-->lca(不含lca,且为前一个松鼠的路径方向)中的某些连续点，但此时方向与之前的方向是相反的，这些连续点是往子结点走，那么我们调整前后两次选择，会得到更优的结果

举例：
16 2
0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 1
4 1
										松鼠1
								房间2      
						松鼠4
					8
			房间16
			
lca 为房间2
第一处（松鼠4）会先选择房间2，
第二处（松鼠1）会选择房间16，
如果不加修正，那么距离为1+4 =5
但更优的选择是：松鼠4 选房间16
				松鼠1 选房间2   总距离3
因此需要修正松鼠lca到4之间的路径代价，dir[4]--；由于update时，calc第二个参数为1，相乘为负，update后，此时松鼠4记录的最近距离和点分别为(1-1,16)，即（0,16）
这样4（除左分支）的其他分支结点上的松鼠选择4左分支上的最近结点的路径代价需要变短，也就是调整策略，调换前后两个松鼠选择的房间（更优）

*/
void dec(int x) {
    update(x);
	//最近结点在当前子树下
    if (x == lca) return;
	//最近结点不在当前子树下，调整方向，往上走
    --dir[x];
    dec(x / 2);
}
/*
修正2：当沿着某结点往下走时，需要修正后续沿着该结点往上走的代价

记最近结点为now.S

当now.S不为lca时，即对于当前松鼠，是沿着lca-->now.S走的，即中间的结点都是往子节点走，修正now.S往lca方向走的路径代价，即如果后续某只松鼠存在now.S-->lca方向中的某些连续边，即lca--->now.S方向(前一松鼠路径方向)上的某些连续点，但此时这些点都是沿着父节点方向走，那么应该减少到目标的距离，即调换前后两次结果更优

举例：
								1
					松鼠2（1只）       房间3（1间）
				4				松鼠6（1只）
			8
	房间16
				
先为松鼠2找房间3，距离2
后为松鼠6找房间16，距离为6
但更优的是(2->16) 、（6->3)   3+1 = 4
修正3到1的之间方向：dir[3]++;使的松鼠6选择3上面分支的结点的距离减少

先修正往上走的代价，即经过3往上：
由于往父节点走calc第二个参数是-1，而dir[3]为正，calc返回-1，即往上走时，上面最近的点距离需要减少(即ret--)，而松鼠6如果要选择1左分支下的房间，会经过6->3，距离减1，到达1时，距离为0（3-->1,距离加1(dir[1] = 0),同时1左分支下最近的房间的距离需要修正，按照修正1的方式即可，也就是0+1+1=2，这样就间接调整了前后两次选择
*/

void inc(int x) {
    update(x);
    if (x == lca) return;
    ++dir[x];
    inc(x / 2);
}

int main() {
    scanf("%d%d", &n, &m);
	//房间的数量
    for (int i = 1; i <= n; i++) scanf("%d", c + i);
	//初始化所有结点都往子节点走，f[x].F表示子节点有房间时，最近的距离   f[x].S表示最近的有房间结点的位置
    for (int i = n; i >= 1; i--) update(i);
    for (int i = 1; i <= m; i++) {
        int p;
        scanf("%d", &p);
        now = pii(MAXN, MAXN);
        query(p, 0);
		//加上最短的距离
        ans += now.F;
		//当前是往上走，修正后续往下走的代价
        dec(p);
		//选择的结点房间数量减一
        --c[now.S];
		//当前是往下走，修正后续往上走的代价
        inc(now.S);
        for (; p; p >>= 1) update(p);
    }
    printf("%d\n", ans);
    return 0;
}
// 5 4
// 0 0 4 1 1
// 5 4 2 2